<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Motion</title>
        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100%; display: block; }
        </style>
    </head>
    <body>
        <script src="js/three.js"></script>
        <script src="js/lodash.js"></script>
        <script src="js/lodash.combinations.js"></script>
        <script>
            // import THREE from "js/three.js";

            class Particle {
                constructor(pos, q, m) {
                    this.pos = pos;
                    this.pos_prev = new THREE.Vector3;
                    this.q = q;
                    this.m = m;

                    this.links = new Map();
                }
                link(p) {
                    length = this.pos.clone().sub(p.pos).length();
                    this.links.set(p, length);
                    p.links.set(this, length);
                }
                unlink(p) {
                    this.links.delete(p);
                    p.links.delete(this);
                }
            }

            class Links {
                constructor() {
                    this.links = new Map;
                }
                has(a) { return this.links.has(a); }
                get(a) { return this.links.get(a); }
                set(a, b) { return this.links.set(a, b); }

                link(i1, i2, len) {
                    if (!this.links.has(i1)) {
                        this.links.set(i1, new Map);
                    }
                    if (!this.links.has(i2)) {
                        this.links.set(i2, new Map);
                    }
                    this.links.get(i1).set(i2, len);
                    this.links.get(i2).set(i1, len);
                }
                unlink(i1, i2) {
                    this.links.get(i1).delete(i2);
                    this.links.get(i2).delete(i1);
                }
            }

            function proj(a, b) {
                return b.clone().normalize().multiplyScalar(a.dot(b.clone().normalize()));
            }

            k = 9e9;
            function coulomb(p1, p2) {
                let r = p1.pos.clone().sub(p2.pos);
                let force = k*p1.q*p2.q / r.length()**2;
                let result = r.clone().normalize().multiplyScalar(force);
                return result;
            }

            function computeForce(i1, particles) {
                let totforce = new THREE.Vector3(0, 0, 0);

                for (let i2 = 0; i2 < particles.length; ++i2) {
                    if (i2 === i1) { continue; }
                    let force = coulomb(particles[i1], particles[i2]);
                    totforce.add(force);
                }

                return totforce;
            }

            function close_enough(a, b, precision=1e-15) {
                return Math.abs(a - b) < precision || Math.abs(a / b - 1) < precision;
            }

            function relax(particles, links) {
                let iterations = 0;
                let adjusted = 1;

                let old_r = [];
                for (let i = 0; i < particles.length; ++i) {
                    let p = particles[i];
                    old_r[i] = p.pos.clone().sub(p.pos_prev);
                }

                while (adjusted) {
                    iterations += 1;
                    adjusted = false;
                    for (let [i1, i2] of _.combinations(_.range(particles.length), 2)) {
                        if (links.has(i1) && links.get(i1).has(i2)) {
                            let max_l = links.get(i1).get(i2);

                            let p1 = particles[i1];
                            let p2 = particles[i2];
                            let r = p2.pos.clone().sub(p1.pos);
                            let act_l = r.length();
                            if (!close_enough(max_l, act_l)) {
                                // adjusted = true;
                                let adjustment = r.clone().normalize().multiplyScalar((act_l - max_l) / 2);
                                // console.log("factor", (act_l - max_l) / max_l * 100);
                                p1.pos.add(adjustment);
                                p2.pos.sub(adjustment);
                            }
                        }
                    }
                }

                for (let i = 0; i < particles.length; ++i) {
                    let p = particles[i];
                    let r = p.pos.clone().sub(p.pos_prev);

                    // let correct_len = old_velocities[i].clone().projectOnVector(r).length();
                    // let correct_velocity = proj(old_velocities[i], r).length();
                    // console.log("correct_len", correct_len);
                    // pr = proj(old_r[i], r);
                    if (r.length() != 0) {
                        pr = old_r[i].clone().projectOnVector(r);
                        let ratio = (r.length() - pr.length()) / pr.length() * 100;
                        p.pos_prev = p.pos.clone().sub(r.clone().normalize().multiplyScalar(pr.length()));
                        console.log(ratio);
                    }
                }

                // console.log("iterations", iterations);
                return particles;
            }

            function step(dt, solution) {
                let dp = [];

                for (let i = 0; i < solution.length; ++i) {
                    let p = solution[i];
                    let acc = computeForce(i, solution).divideScalar(m);
                    let velocity = (p.pos.clone().sub(p.pos_prev)).divideScalar(dt);

                    p.pos_prev = p.pos.clone();
                    velocity.add(acc.multiplyScalar(dt));
                    dp.push(velocity.multiplyScalar(dt));
                }

                for (let i = 0; i < solution.length; ++i) {
                    solution[i].pos.add(dp[i]);
                }

                return relax(solution, links);
            }

            // углерод
            m = 2e-26;
            // m = 2e-30;
            q = 1.6e-19;
            radius = 77e-12;
            d = radius*2;
            distance = 1.42e-10;
            dt = 1e-15;

            let particles = [
                new Particle(new THREE.Vector3(-1, 1, 0).multiplyScalar(distance/2), q, m),
                new Particle(new THREE.Vector3(1, 1, 0).multiplyScalar(distance/2), q, m),
                new Particle(new THREE.Vector3(1, -1, 0).multiplyScalar(distance/2), q, m),
                new Particle(new THREE.Vector3(-1, -1, 0).multiplyScalar(distance/2), q, m)
            ];

            links = new Links();
            // links.link(0, 1, particles[0].pos.distanceTo(particles[1].pos));
            links.link(1, 2, particles[1].pos.distanceTo(particles[2].pos));
            links.link(2, 3, particles[2].pos.distanceTo(particles[3].pos));
            links.link(3, 0, particles[3].pos.distanceTo(particles[0].pos));


            /* simulation */

            let scene = new THREE.Scene();
            let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, distance/100, 100*distance);
            camera.position.z = distance * 2;

            let renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);


            let tex = new THREE.TextureLoader().load("https://threejs.org/examples/textures/sprites/disc.png");

            geometry = new THREE.Geometry();
            material = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: distance / 10,
                blending: THREE.AdditiveBlending,
                transparent: true,
                map: tex
            });

            // let trackballControls = new THREE.TrackballControls(camera);


            for (i = 0; i < particles.length; ++i) {
                geometry.vertices[i] = particles[i].pos;
            }

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);

            particleSystem.sortParticles = true;

            function update() {
                renderer.render(scene, camera);
                requestAnimationFrame(update);

                particles = step(dt, particles);
                // particleSystem.rotation.y += 0.03;

                for (i = 0; i < particles.length; ++i) {
                    let p = particles[i].pos;
                    geometry.vertices[i].set(p.x, p.y, p.z);
                    // console.log(p);
                }

                let lookat = (particles[2].pos.clone().add(particles[3].pos).multiplyScalar(1/2));
                camera.position.x = lookat.x;
                camera.position.y = lookat.y;

                particleSystem.geometry.verticesNeedUpdate = true;
            }

            update();

        </script>
    </body>
</html>