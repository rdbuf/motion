<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Motion</title>
        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100%; display: block; }
        </style>
    </head>
    <body>
        <script src="js/three.js"></script>
        <script src="js/lodash.js"></script>
        <script>

            class Particle {
                constructor(pos, q, m) {
                    this.pos = pos;
                    this.pos_prev = new THREE.Vector3;
                    this.q = q;
                    this.m = m;

                    this.links = new Map();
                }
                link(p) {
                    length = this.pos.clone().sub(p.pos).length();
                    this.links.set(p, length);
                    p.links.set(this, length);
                }
                unlink(p) {
                    this.links.delete(p);
                    p.links.delete(this);
                }
            }

            class Links {
                constructor() {
                    this.links = new Map;
                }
                has(a) { return this.links.has(a); }
                get(a) { return this.links.get(a); }
                set(a, b) { return this.links.set(a, b); }

                link(i1, i2, len) {
                    if (!this.links.has(i1)) {
                        this.links.set(i1, new Map);
                    }
                    if (!this.links.has(i2)) {
                        this.links.set(i2, new Map);
                    }
                    this.links.get(i1).set(i2, len);
                    this.links.get(i2).set(i1, len);
                }
                unlink(i1, i2) {
                    this.links.get(i1).delete(i2);
                    this.links.get(i2).delete(i1);
                }
            }

            function proj(a, b) {
                return b.clone().normalize().multiplyScalar(a.dot(b.clone().normalize()));
            }

            k = 9e9;
            function coulomb(p1, p2) {
                let r = p1.pos.clone().sub(p2.pos);
                let force = k*p1.q*p2.q / r.length()**2;
                let result = r.clone().normalize().multiplyScalar(force);
                return result;
            }

            function computeForce(i1, particles) {
                let totforce = new THREE.Vector3(0, 0, 0);

                for (let i2 = 0; i2 < particles.length; ++i2) {
                    if (i2 === i1) { continue; }
                    let force = coulomb(particles[i1], particles[i2]);
                    totforce.add(force);
                }

                for (let i2 = 0; i2 < particles.length; ++i2) {;
                    if (links.get(i1)) {
                        let l = links.get(i1).get(i2);
                        if (l) {
                            let r = particles[i2].pos.clone().sub(particles[i1].pos);
                            totforce.add(proj(totforce.clone(), r));
                        }
                    }
                }

                return totforce;
            }

            function relax(particles, links) {
                let adjusted = 1;
                while (adjusted) {
                    adjusted = false;
                    for (let i1 = 0; i1 < particles.length; ++i1) {
                        if (links.has(i1)) {
                            for (let i2 = 0; i2 < particles.length; ++i2) {
                                if (i1 == i2) {
                                    continue;
                                }
                                if (links.get(i1).has(i2)) {
                                    let max_l = links.get(i1).get(i2);

                                    let p1 = particles[i1];
                                    let p2 = particles[i2];
                                    let r = p2.pos.clone().sub(p1.pos);
                                    let act_l = r.length();
                                    // console.log(act_l);
                                    if (act_l > max_l) {
                                        // adjusted = true;
                                        let adjustment = r.clone().normalize().multiplyScalar((act_l - max_l) / 2);
                                        console.log(adjustment);
                                        p1.pos.add(adjustment);
                                        p2.pos.sub(adjustment);
                                    }
                                }
                            }
                        }
                    }
                }

                return particles;
            }

            function step(dt, solution) {
                let new_solution = _.cloneDeep(solution);

                for (let i = 0; i < new_solution.length; ++i) {
                    let p = new_solution[i];
                    let acc = computeForce(i, solution).divideScalar(m);
                    let velocity = (p.pos.clone().sub(p.pos_prev)).divideScalar(dt);

                    p.pos_prev = p.pos.clone();
                    velocity.add(acc.multiplyScalar(dt));
                    p.pos.add(velocity.multiplyScalar(dt));
                }

                return relax(new_solution, links);
                // return new_solution;
            }

            // углерод
            m = 2e-26;
            q = 1.6e-19;
            radius = 77e-12;
            d = radius*2;
            distance = 1.42e-10;
            let particles = [
                new Particle(new THREE.Vector3(1, 1, 0).multiplyScalar(distance/2), q, m),
                new Particle(new THREE.Vector3(-1, 1, 0).multiplyScalar(distance/2), q, m),
                new Particle(new THREE.Vector3(-1, -1, 0).multiplyScalar(distance/2), q, m),
                new Particle(new THREE.Vector3(1, -1, 0).multiplyScalar(distance/2), q, m)
            ];

            links = new Links();
            links.link(0, 1, particles[0].pos.distanceTo(particles[1].pos));
            links.link(1, 2, particles[1].pos.distanceTo(particles[2].pos));
            links.link(2, 3, particles[2].pos.distanceTo(particles[3].pos));
            links.link(3, 0, particles[3].pos.distanceTo(particles[0].pos));


            /* simulation */

            let scene = new THREE.Scene();
            let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, distance/100, 100*distance);
            camera.position.z = distance*20;

            let renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);


            let tex = new THREE.TextureLoader().load("https://threejs.org/examples/textures/sprites/disc.png");

            geometry = new THREE.Geometry();
            material = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: d/2,
                blending: THREE.AdditiveBlending,
                transparent: true,
                map: tex
            });

            for (i = 0; i < particles.length; ++i) {
                geometry.vertices[i] = particles[i].pos;
            }

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);

            particleSystem.sortParticles = true;

            function update() {
                renderer.render(scene, camera);
                requestAnimationFrame(update);

                let dt = 1e-14;
                particles = step(dt, particles);
                // particleSystem.rotation.y += 0.03;

                for (i = 0; i < particles.length; ++i) {
                    let p = particles[i].pos;
                    geometry.vertices[i].set(p.x, p.y, p.z);
                    // console.log(p);
                }

                particleSystem.geometry.verticesNeedUpdate = true;
            }

            update();
            
        </script>
    </body>
</html>